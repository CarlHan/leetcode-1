### 1）假设数组里面没有0

* 如果前i个元素(包括元素i)中负数的个数为偶数，则前i个元素相乘的结果就是**最大值**，记为**maxLocal**
* 如果前i个元素(包括元素i)中负数的个数为奇数，则前i个元素相乘的结果会是**最小值**，记为**minLocal**

考虑元素i+1，假设值为num

* 如果元素i+1为负数，则包含元素i+1的**最大值**为maxLocal\*num
* 如果元素i+1为整数，则包含元素i+1的**最小值**为minLocal\*num

### 2）数组里面包含0

* 如果包含0，对于元素0之前的结果，还是符合1）中的分析
* 对于元素0，如果包含该元素，则**最大值和最小值**都为0
* 对于元素0之后的元素，因为前面求得的最大最小值包含0，所以需要考虑不包含前面元素的情况，即只包含当前元素（假设i+1为1，而前一个元素为0，如果包含0最大最小值都为0，而只包含i+1的结果才是最大值）

也就是说，如果maxLocal或minLocal为0，则考虑一个新元素时，不能仅仅只根据该元素与maxLocal，minLocal的乘积来更新这两个值，还要考虑该元素单独作为子数组的情况

### 结合

如果分情况讨论，会很复杂，0的个数和位置都不确定

在1）这种情况下：
* 当前maxLocal = max(前一maxLocal\*num , 前一minLocal\*num)
* 当前minLocal = min(前一maxLocal\*num , 前一minLocal\*num)

而2）这种情况下：
* 当前maxLocal = max(前一maxLocal\*num , 前一minLocal\*num , num)
* 当前minLocal = min(前一maxLocal\*num , 前一minLocal\*num , num)

所以考虑1）能否也使用2）这种表达式，由于数组不包含0，单独的一个元素不可能成为最小值或最大值，所有将num也作为比较并不影响结果
